{"output":"Para cada caso de teste, escreva uma linha contendo a frequência de acesso para cada nó em ordem crescente de valores dos nós. Para evitar problemas de precisão, as frequências devem ser escritas como números inteiros, significando que a probabilidade de acesso de um nó será a frequência dividida pela soma de todas as frequências. Certifique-se que você não escreverá qualquer inteiro maior que 263 - 1 (o valor máximo que cabe no tipo long long para C/C++ ou long para Java). Caso contrário, você poderá produzir uma solução qualquer sem a garantia de que é exatamente uma árvore binária de busca ótima: a árvore binária de busca dada na entrada.","input":"O entrada contém vários casos de teste. Cada caso inicia com um inteiro n (1 ≤ n ≤ 50), que é o número de nós de uma árvore binária de busca ótima. Para simplificar, os valores dos nós serão inteiros de 1 a n. A seguir temos n linhas que descrevem a estrutura da árvore. A i-ésima linha contém os valores dos nós da sub-árvore esquerda e direita com valor i (ou -1 para uma árvore vazia). Você pode assumir que a entrada sempre conterá uma árvore binária de busca válida.\n\n                    O último caso é seguido por um zero.\n\n                    Note que o primeiro caso de teste no exemplo de entrada descreve uma árvore parecida com:\n\n                       2\n                     /  \\\n                    1    3","level":7,"name":"Ajude o Autor do Problema","has_images":false,"description":"Preparar um problema para uma competição de programação leva muito tempo. Você não somente tem que escrever a descrição e a solução de um problema, mas você também tem que criar arquivos de entrada difíceis. Nesse problema, você terá a chance de ajudar o autor de problemas a criar algumas entradas para um determinado problema.\n\n                    Para isso vamos selecionar o problema que não foi resolvido durante uma competição local no ano passado. O problema era encontrar a árvore binária de busca ótima, dado a probabilidade de que certos nós são acessados. Seu trabalho será: dado a árvore binária de busca ótima desejada, descubra algumas probabilidades de acesso para que esta seja a única e melhor árvore. Não se preocupe se você não leu o problema no ano passado, pois todas as definições exigidas foram colocadas abaixo.\n\n                    Vamos definir uma árvore binária de busca indutivamente da seguinte forma:\n\n                    \n                    \tUma árvore vazia que não possui nenhum nó é uma árvore binária de busca;\n                    \tCada árvore binária de busca não vazia possui uma raiz, que é um nó identificado por um inteiro e duas sub-árvores uma a direita e outra a esquerda da raiz;\n                    \tA sub-árvore da esquerda não contém nenhum nó com rótulo ≥ que o rótulo da raiz;\n                    \tA sub-árvore da direira não contém nenhum nó com rótulo ≤ que o rótulo da raiz.\n                    \n\n                    Dado tal árvore de busca binária, o seguinte procedimento de busca pode ser usado para localizar um nó na árvore:\n\n                    Começe com a raiz. Compare o rótulo do nó atual com o rótulo do nó desejado. Se forem iguais, você encontrou o nó correto. Caso contrário, se o rótulo desejado for menor busqye na sub-árvore da esquerda, senão, busca na sub-árvore da direita.\n\n                    O custo de acesso para localizar um nó é o número de nós que você visitou até encontrar o nó certo. Uma árvore binária de busca ótima é uma árvore com o mínimo custo esperado.","id":"1668","category":"Grafos","statistics":{"level":"7 / 10","submissions":29,"solved":10,"ratio":"34.48%"}}