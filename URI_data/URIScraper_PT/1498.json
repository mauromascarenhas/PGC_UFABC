{"output":"Para cada caso de teste de entrada, imprima uma linha com um inteiro que representa o tamanho mínimo (número total de caracteres) que o texto pode ter assim como os códigos gerados têm os comprimentos determinados.","input":"A entrada contém vários casos de teste e terminam com EOF. A primeira linha de cada caso de teste contém um inteiro N (2 ≤ N ≤ 50) que representa o número de caracteres diferentes que aparece no texto. A segunda linha contém N inteiros Li indicam os comprimentos dos códigos escolhido pelo algoritmo de Huffman para os diferentes caracteres (1 ≤ Li ≤ 50 para i = 1, 2, ..., N). você pode assumir que existe pelo menos uma árvore, construída tal como descrito, que produz códigos com o dado comprimentos.","level":10,"name":"Inversão de Huffman","has_images":true,"description":"Codificação Estática de Huffman é um algoritmo de codificação usado principalmente para compressão de texto. Dado um texto de determinado tamanho feito de n caracteres diferentes, o algoritmo escolhe N códigos , um para cada diferente caractere. O texto é compactado usando esses códigos. Para escolher os códigos, o algoritmo constrói uma árvore binária com N folhas. Para N ≥ 2 a árvore pode ser construído como se segue. 1. Para cada caractere diferente no texto construa uma árvore contendo apenas um único nodo, e atribua a ele um peso coincidente com o número de ocorrências de caracteres no texto.\n\t\t\t\t\t2. Construia um conjunto s contendo as N árvores acima.\n\t\t\t\t\t3. Enquanto s contiver mais de uma árvore:\n\t\t\t\t\t(a) Escolha t1 ∈ s com peso mínimo e remova-o de s.\n\t\t\t\t\t(b) Escolha t2 ∈ s com peso mínimo e remova-o de s.\n\t\t\t\t\t(c) Crie uma nova árvore t com t1 como a sua subárvore esquerda e t2 como sua subárvore direita e atribua para t a soma dos pesos de t1 e t2.\n\t\t\t\t\t(d) Inclua t em s.\n\t\t\t\t\t4. Retorne a única árvore que sobrar em s .\n\n\t\t\t\t\tPara o texto \"abracadabra\" , a árvore produzido pelo processo acima descrito pode ser semelhante a imagem à esquerda, onde cada nodo interno é marcado com o peso da sub-árvore esquerda daquele nodo. Note que a árvore obtida também pode se parecer com a imagem da direita, entre outras coisas, porque nas etapas 3a e 3b do conjunto s pode conter várias árvores com peso mínimo. Para cada caractere diferente do texto, seu código depende do caminho que existe na árvore final, à partir da raiz até a folha correspondente ao caracter. O tamanho do código é o número de arestas existentes no caminho (que coincide com o número de nodos internos do caminho). Assumindo que a árvore da esquerda foi construída por um algoritmo, o código para \u201cr\u201d tem tamanho 3 enquanto que o código para \u201cd\u201d tem tamanho 4. \n\t\t\t\t\t\n\t\n\t\t\t\t\tSua tarefa é, dado os tamanhos dos N códigos escolhidos pelo algoritmo, encontrar a árvore mínima (em número total de caracteres) que o texto poderá ter de forma que os códigos gerados tenham comprimento N","id":"1498","category":"Grafos","statistics":{"level":"10 / 10","submissions":145,"solved":51,"ratio":"35.17%"}}