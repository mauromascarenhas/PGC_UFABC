{"output":"For each test case, print a line with the word \"vazia\" if the CFG generates no strings of terminals, or the word \"finita\" if the CFG generates some, but not infinite strings of terminals, or the word \"infinita\" if the CFG generates infinite strings of terminals.","input":"The input contains many test cases. Each test case describes a context-free grammar.\r\n\r\n\t\t\t\t\tThe first line of a test case contains two integers v and r, where v is the amount of variables of the CFG, r is the amount of rules, 1 ≤ v ≤ 102 and 0 ≤ r ≤ 2·102.\r\n\r\n\t\t\t\t\tEach one of the next v lines contains a word made of uppercase letters, a variable of the CFG. The variable in the first line is the start variable.\r\n\r\n\t\t\t\t\tEach one of the next r lines describes a rule of the CFG. A word of uppercase letters is given, an integer 0 ≤ k ≤ 102 and a sequence of k elements, where each element is a variable, or a terminal symbol.","level":10,"name":"Is The Language Infinite?","has_images":false,"description":"Context-free grammar \u2013 CFG \u2013 is a mathematical structure used to generate strings, which are finite sequences of terminal symbols. The set of all strings that can be generated by CFG G is the language of G, written L(G). In this problem, given a CFG G, you must tell if L(G) is an empty set, finite, or infinite.\r\n\r\n\t\t\t\t\tA CFG is a 4-tuple (V, Σ, R, S), where\r\n\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tV is a finite and non-empty set whose elements are called variables.\r\n\t\t\t\t\t\tΣ is a finite and non-empty set, disjoint of V, whose elements are called terminal symbols.\r\n\t\t\t\t\t\tR is a set of rules. A rule has the form\r\n\t\t\t\t\t\tA → U1U2...Uk\r\n\t\t\t\t\t\twhere A ∈ V, k ≥ 0 and Ui ∈ V ∪ Σ for i = 1,2,...,k.\r\n\t\t\t\t\t\tS ∈ V is the start variable.\r\n\t\t\t\t\t\r\n\r\n\t\t\t\t\tTo generate a string using a CFG, we run the following procedure.\r\n\r\n\t\t\t\t\tFirst, write the start variable S. Next, choose a rule to substitute S, say, S → U1U2...Uk. After this choice, erase the S and write in its place the string of variables and/or terminals U1U2...Uk. Repeat this process until no variable is left written. If it's not possible to generate a string without variables starting with the start variable, we say that the CFG's language is empty.\r\n\r\n\t\t\t\t\tFor example, let be the CFG below, where S is the start variable.\r\n\r\n\t\t\t\t\tS → aSa\r\n\r\n\t\t\t\t\tS → bSb\r\n\r\n\t\t\t\t\tS → a\r\n\r\n\t\t\t\t\tS → b\r\n\r\n\t\t\t\t\tS → \r\n\r\n\t\t\t\t\tUsing the CFG above, we can generate any palindrome made of a's and b's. For example:\r\n\r\n\t\t\t\t\tS → aSa → abSba → abba\r\n\r\n\t\t\t\t\tObserve that the empty string is a valid string. So, if a CFG G generates, for example, only the empty string, L(G) is finite, but not empty.\r\n\r\n\t\t\t\t\tIn this problem, the variables will be words made only of uppercase letters, that is, characters between A and Z. The terminal symbols will be lowercase letters, that is, characters between a and z. The rules will be in the format described in the next section. The start variable will always be the first variable of the test case.","id":"1826","category":"Graph","statistics":{"level":"10 / 10","submissions":67,"solved":30,"ratio":"44.78%"}}