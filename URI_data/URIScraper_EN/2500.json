{"output":"The output consists of one line per test case containing the value of the K-th position of the sequence after applied M times the w-xor on it.","input":"The input consists of several test cases. Each test case begins with three integers 2 ≤ N ≤ 103, 1 ≤ M ≤ 106  and 1 ≤ K ≤ N representing the number of elements of the sequence, the number of w-xor operations applied and the position of the value to be found (note that the first position is 1), respectively. On the next line, there will be N integer values \u200b\u200b-109 ≤ Ai ≤ 109. The entry ends when N=M=K=0.","level":8,"name":"William Xorando","has_images":false,"description":"William recently learned some properties of the bit to bit operator xor (represented by the operator '^' in C language ). He realized that he can do many interesting algorithms with it: Find lonely elements in a sequence, exchange values \u200b\u200bwithout auxiliary variable, encryption and many others. Then he began to experiment and decided to name an operation using xor with its name, the w-xor. The w-xor operation is performed on a sequence of values. Example: it is an S={a1, a2, a3, a4}, applying w-xor over the sequence S once is equivalent to:\r\n\r\na1= a1^a2^a3^a4\r\n\r\na2= a1^a2^a3^a4\r\n\r\na3= a1^a2^a3^a4\r\n\r\na4= a1^a2^a3^a4\r\n\r\na1= a1^a2^a3^a4\r\n\r\nIf S={a1, a2, a3, a4, a5} then applying w-xor over S once is:\r\n\r\na1= a1^a2^a3^a4^a5\r\n\r\na2= a1^a2^a3^a4^a5\r\n\r\na3= a1^a2^a3^a4^a5\r\n\r\na4= a1^a2^a3^a4^a5\r\n\r\na5= a1^a2^a3^a4^a5\r\n\r\na1= a1^a2^a3^a4^a5\r\n \r\n\r\nGiven a sequence S and applying w-xor M times over it, you would know what the value of the K-th position?","id":"2500","category":"Ad-Hoc","statistics":{"level":"8 / 10","submissions":220,"solved":61,"ratio":"27.73%"}}