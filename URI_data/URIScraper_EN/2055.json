{"output":"For each instance your program should print a line containing Instancia k, where k is the number of the k-est instance. For each phone number processed your program should print all the possible encodings in ascending lexicographical order (ASCII order). Each encoding must be printed in the following format: the phone number followed by colon (:), an empty space and the encoding. A blank line must be printed between 2 test cases.","input":"Each instance is composed by a line with an integer 0 < n â‰¤ 75000, the number of words in the dictionary. The next n lines have words with at most 50 characters. After the dictionary follows an integer 1 < t < 100000, and in the t following lines follows the phone numbers the must be encoded. When n is 0, your program must stop.","level":9,"name":"Lisp is Better than Java, C and C++","has_images":true,"description":"However, differently of traditional benchmarks, Prechelt compared different implementations of the same task made by 38 different developers (in experience and knowledge). Prechelt's study showed that Java is from 3 to 4 times slower than C or C++, but the greater variations ocurred between the programmers, not between the languages, suggesting that it's better to spend more time training the developers instead of discussing which language should be picked.\n\n                    Years later Garret extended this study adding Lisp as one of the possible implementations to the problem, and this time, besides considering the comparing factors used by Prechelt, he added the development time as metric. Garret's results were surprising: Lisp was the best in all aspects, requiring less time and code lines, using less memory and executing faster than the programs in C, C++ or Java. It was proven that Lisp programmers are much better than other programmers. This is your chance to prove that Garret's study was wrong. How? Solving the same problem, in less time and with faster implementations.\n\n                    The problem that was the base of both studies is the following: Consider the following mapping between letters and digits:\n\n                    \n\n\n                    We want to use this mapping to code phone numbers into words in a way that it becomes easier to memorize. Your task is to write a program that finds, given a phone number, all it's possible coding in words. A phone number is an arbitrary string with only hifen (-), slashes (/) and digits. The hifen and slashes should not be encoded. The words are taken from a dictionary informed in alphabetic order. You should print only the words that completely encode the phone number. The dictionary words may have upper and lower case letters, hifen (-) and quotation marks (\"), but you must use only the letters to encode a number. The word must be printed as given in the dictionary. The encoding of a phone number may consist of one or more words, separated by a single space. The encoding is made word by word, from left to right. If at some point of the encoding no word from the dictionary can be inserted, then a single digit of the number can be used in the encoding, but two consecutive numbers aren't allowed in a valid encoding. In other words: in a parcial encoding that covers k digits, the digit k+1 is encoded by itself if and only if, first, the digit k wasn't encoded by a digit and, second, there isn't any word in the dictionary that can be used in the encoding starting from digit k+1.","id":"2055","category":"Strings","statistics":{"level":"9 / 10","submissions":57,"solved":7,"ratio":"12.28%"}}